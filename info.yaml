---
project:
  wokwi_id:    0        # If using wokwi, set this to your project's ID

  source_files:
    - grey.v
    - dwisehart_top.v
  top_module:  "dwisehart_top"

yaml_version: 3.0

documentation:
  author:       "Daniel Wisehart"
  title:        "Base-10 grey counter from zero to a billion"
  language:     "Verilog"
  description:  "Change only one output bit per count, but count with decimal digits instead of the usual reverse bit order grey counter."

  how_it_works: |
      Like a standard grey counter, this counter will only change one bit per time, but the bits are grouped into
      decimal digits.  (This also makes for easy bits -> decimal decoding for the interested.)

      Each decimal digit uses five bits.  As with all grey counters, you have to scan the counter output fast
      enough that either the value is the same or the value has only increased by one between scans.  If you scan
      too slowly and the value changes by 2 or more, then the grey counter can and will give you bad counts.

      As an exampe of how this grey counter works, this is the progression of grey bits with the project when
      counting from from decimal 0 to 12:
      \begin{tabular}{rrl}
      10's  & 1's   & count \\
      00000 & 00000 & 0     \\
      00000 & 00001 & 1     \\
      00000 & 00011 & 2     \\
      00000 & 00010 & 3     \\
      00000 & 00110 & 4     \\
      00000 & 00100 & 5     \\
      00000 & 01100 & 6     \\
      00000 & 01000 & 7     \\
      00000 & 11000 & 8     \\
      00000 & 10000 & 9     \\
      00001 & 00000 & 10    \\
      00001 & 00001 & 11    \\
      00001 & 00011 & 12
      \end{tabular}

      But wait, you say, at decimal value 10, two bits change at once.  This is where your deciphering of the bits
      has to be smart.

      The bits in the 10's digit change 10x more slowly than the 1's digit.  So when you decipher the combined
      value, you look first at the 10's digit.  If the 10's digit has changed, then you can ignore the 1's digit,
      because you know the combined value is 10 or 20 or ... 90 or back to 00.  If the 10's digit has not changed,
      then you look at both digits to decipher the combined value: 1 or 2 or ... 98 or 99.

      Some work has been done to insure that the 10's digit changes before the 1's digit, but if the physical
      routes between the outputs of this circuit and the inputs to your scanning circuit make the 10's bits
      arrive at your inputs later than the 1's bits, you can and will receive 1's bits that change from 9 ('b10000)
      to 0 ('b00000) even though you have not yet seen the 10's bits change.  That can be worked around because you
      can deduce that the 10's digit has rolled over, so you update your internal copy of the 10's bits.  Better to
      keep the input paths the same length or make the 1's bits use a longer path than the 10's bits.

      Note that in this implementation, the TinyTapeout PCB hardware--which only has 8 outputs--outputs the slowest
      changing bits of the hundred million digit and the three fastest changing bits of the ones digit.  To see all
      bits flip, you have to run this in the simulator or with cocotb.  Here are the bits that are connected to the
      hardware outputs.

      \begin{tabular}{lrll}
      output 7 & 100M's & bit 4 & X.... \\
      output 6 & 100M's & bit 3 & .X... \\
      output 5 & 100M's & bit 2 & ..X.. \\
      output 4 & 100M's & bit 1 & ...X. \\
      output 3 & 100M's & bit 0 & ....X \\
      output 2 & 1's    & bit 2 & ..X.. \\
      output 1 & 1's    & bit 1 & ...X. \\
      output 0 & 1's    & bit 0 & ....X
      \end{tabular}

  how_to_test:  |
      After reset goes low, the counter should increase by one with each rising edge of the clock.
      You are encouraged to try different clock rates.  If you load a 45 bit value into the init input before you
      assert reset, that bit pattern will be loaded into the grey counter.

      If you enter `make` from the src directory, a cocotb test will run and report the results.  Inside of test.py
      there is a RANGE constant at the top of the file which you can use to tell cocotb how many different values
      to check.  Here are some representative test times:

      \begin{tabular}{lr}
      RANGE =     10,000 &    2 sec \\
      RANGE =    100,000 &   19 sec \\
      RANGE =  1,000,000 &  189 sec \\
      RANGE = 10,000,000 & 1890 sec \\
      \end{tabular}

  inputs:
    - clock
    - reset
    - none
    - none
    - none
    - none
    - none
    - none

  outputs:
    -    1's bit 0
    -    1's bit 1
    -    1's bit 2
    - 100M's bit 0
    - 100M's bit 1
    - 100M's bit 2
    - 100M's bit 3
    - 100M's bit 4

  tag:          "counter, grey, test"
  external_hw:  ""
  discord:      "danielwyo#2929"
  doc_link:     ""
  clock_hz:     any
  picture:      ""
