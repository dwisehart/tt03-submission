---
project:
  wokwi_id:    0        # If using wokwi, set this to your project's ID

  source_files:
    - grey.v
    - dwisehart_top.v
  top_module:  "dwisehart_top"

yaml_version: 3.0

documentation:
  author:       "Daniel Wisehart"
  title:        "Base-10 grey counter up to 100 million"
  language:     "Verilog"
  description:  "Change only one output bit per count, but count with decimal digits instead of the usual reverse bit order grey counter."

  how_it_works: |
      Like a standard grey counter, this counter will only change one bit per time, but the bits are grouped into
      decimal digits.  (This also makes for easy bits -> decimal decoding for the interested.)

      Each decimal digit uses five bits.  As with all grey counters, you have to scan the counter output fast
      enough that either the value is the same or the value has increased by one.  If you scan too slowly and the
      value changes by 2 or more, then the grey counter can give you false indications: only a single bit, at most,
      should change between scans.

      As an exampe of how this grey counter works, this is the progression from decimal 0 to 12:
      \begin{tabular}{rrr}
      10's                                                 & 1's   & \multicolumn{1}{l}{count} \\
      00000                                                & 00000 & 0                         \\
      00000                                                & 00001 & 1                         \\
      00000                                                & 00011 & 2                         \\
      00000                                                & 00010 & 3                         \\
      00000                                                & 00110 & 4                         \\
      00000                                                & 00100 & 5                         \\
      00000                                                & 01100 & 6                         \\
      00000                                                & 01000 & 7                         \\
      00000                                                & 11000 & 8                         \\
      00000                                                & 10000 & 9                         \\
      00001                                                & 00000 & 10                        \\
      00001                                                & 00001 & 11                        \\
      00001                                                & 00011 & 12
      \end{tabular}

      But wait, you say, at decimal value 10, two bits change at once.  This is where your deciphering of the bits
      has to be smart.

      The bits in the 10's digit change 10x more slowly than the 1's digit.  So when you decipher the combined
      value, you look first at the 10's digit.  If the 10's digit has changed, then you can ignore the 1's digit,
      because you know the combined value is 10 or 20 or ... 90 or back to 00.  If the 10's digit has not changed,
      then you look at both digits to decipher the combined value: 1 or 2 or ... 98 or 99.

      Some work has been done to insure that the 10's digit changes before the 1's digit, but if the physical
      routes between the outputs of this circuit and the inputs of your scanning circuit make the 10's output bits
      arrive later, it is possible that you will receive a 1's bit that changes from 9 ('b10000) to 0 ('b00000)
      even though you have not yet seen the 10's value change.  That is fine.  You know that the 10's digit has
      rolled over, and you update your internal copy of the 10's digit so that on the next clock cycle you do not
      detect a change in the 10's digit.

      Note that in this implementation, the hardware--which only has 8 outputs--outputs the thousands digit and the
      three fastest changing bits of the ones digit.  To see all bits flip, you have to run this in the simulator
      or with cocotb.

      \begin{tabular}{llllll}
      - & segment & a & 100M's & bit 4 & X.... \\
      - & segment & b & 100M's & bit 3 & .X... \\
      - & segment & c & 100M's & bit 2 & ..X.. \\
      - & segment & d & 100M's & bit 1 & ...X. \\
      - & segment & e & 100M's & bit 0 & ....X \\
      - & segment & f & 1's    & bit 2 & ..X.. \\
      - & segment & g & 1's    & bit 1 & ...X. \\
      - & segment & h & 1's    & bit 0 & ....X
      \end{tabular}

  how_to_test:  |
      After reset goes low, the counter should increase by one with each rising edge of the clock.
      You are encouraged to try different clock rates.

      If you enter `make` from the src directory, a cocotb test will run and report the results.

  inputs:
    - clock
    - reset
    - none
    - none
    - none
    - none
    - none
    - none

  outputs:
    - 100M's bit 4
    - 100M's bit 3
    - 100M's bit 2
    - 100M's bit 1
    - 100M's bit 0
    - 1's    bit 2
    - 1's    bit 1
    - 1's    bit 0

  tag:          "counter, grey, test"
  external_hw:  ""
  discord:      "danielwyo#2929"
  doc_link:     ""
  clock_hz:     any
  picture:      ""
